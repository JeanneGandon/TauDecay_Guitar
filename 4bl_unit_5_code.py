# -*- coding: utf-8 -*-
"""4bl unit 5 code

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12CZeLHXCqffHKYatzWuwLfER7dNRNm1S
"""

import numpy as np
from scipy.io import wavfile
edata = np.loadtxt('/content/Unit 5 data - electric d.wav.csv') #import sound file
adata = np.loadtxt('/content/Unit 5 data - acoustic d.wav.csv') #import sound file
import matplotlib.pyplot as plt
from scipy.optimize import least_squares

ao=1.0 #normalized initial amiplitude

#defined functions to help calculate fitted curve
def modeled(x, parameters):
  '''
  Inputs:
    x: a coordinate
    parameters: [ao, Tau]
  '''
  #ao = parameters[0]
  Tau = parameters[1]
  V = (ao)*(np.exp(-1*x/(Tau)))  #exponential model
  return V

def get_residuals(parameters, data, x):  #residuals function
  residuals = np.abs(data - modeled(x, parameters))
  return -residuals



#trim the data
etrimdata= edata[110:220]
atrimdata= adata[32:160]

#sampling rate

erate=20
esamp_period = 1. / erate #sample data
enum_data_points = len(etrimdata)#number of data pnts
print('ESampling Rate: ' + str(erate)+' data points per second')

arate=20
asamp_period = 1. / arate #sample data
anum_data_points = len(atrimdata)#number of data pnts
print('ASampling Rate: ' + str(arate)+' data points per second')

exaxis = np.arange(len(etrimdata)) * esamp_period # Make our axis go from 0 to the length of our recording
ex_vals= np.arange(len(etrimdata))*(1/20)

eoffsetdata = etrimdata-min(etrimdata)
enormaldata = eoffsetdata/max(eoffsetdata)#normalize

axaxis = np.arange(len(atrimdata)) * asamp_period # Make our axis go from 0 to the length of our recording
ax_vals= np.arange(len(atrimdata))*(1/20)

aoffsetdata = atrimdata-min(atrimdata)
anormaldata = aoffsetdata/max(aoffsetdata)#normalized

eguess_parameters_ = [1, 1] ##perform least squares and fit for electric guitar
eres_lsq = least_squares(get_residuals, eguess_parameters_, args = (enormaldata,ex_vals))
eparameters= eres_lsq['x']
ey_vals = modeled(exaxis, eparameters)

plt.plot(ex_vals, ey_vals, color="red", label="Fitted Electric Data")
plt.plot(exaxis, enormaldata, color='blue', label='Normal Electric Data')

aguess_parameters_ = [1, 1] ##perform least squares and fit for acoustic guitar
ares_lsq = least_squares(get_residuals, aguess_parameters_, args = (anormaldata,ax_vals))
aparameters= ares_lsq['x']
ay_vals = modeled(axaxis, aparameters)

plt.plot(ax_vals, ay_vals, color="green", label="Fitted Acoustic Data")
plt.plot(axaxis, anormaldata, color='brown', label ='Normal Acoustic Data')
plt.title('D Dampening over Time')
plt.xlabel('Time (s)')#graph labeling
plt.ylabel('Intensity')
plt.legend()
print(eparameters)
print(aparameters)

import numpy as np
from scipy.io import wavfile
edata = np.loadtxt('/content/Unit 5 data - electric g.wav.csv') #import sound file
adata = np.loadtxt('/content/Unit 5 data set 2 - acoustic g v3.wav.csv') #import sound file
import matplotlib.pyplot as plt
from scipy.optimize import least_squares

ao=1.0 #normalized initial amiplitude

#defined functions to help calculate fitted curve
def modeled(x, parameters):
  '''
  Inputs:
    x: a coordinate
    parameters: [ao, Tau]
  '''
  #ao = parameters[0]
  Tau = parameters[1]
  V = (ao)*(np.exp(-1*x/(Tau)))  #exponential model
  return V

def get_residuals(parameters, data, x):  #residuals function
  residuals = np.abs(data - modeled(x, parameters))
  return -residuals



#trim the data
etrimdata= edata[85:250]
atrimdata= adata[195:320]

#sampling rate

erate=20
esamp_period = 1. / erate #sample data
enum_data_points = len(etrimdata)#number of data pnts
print('ESampling Rate: ' + str(erate)+' data points per second')

arate=20
asamp_period = 1. / arate #sample data
anum_data_points = len(atrimdata)#number of data pnts
print('ASampling Rate: ' + str(arate)+' data points per second')

exaxis = np.arange(len(etrimdata)) * esamp_period # Make our axis go from 0 to the length of our recording
ex_vals= np.arange(len(etrimdata))*(1/20)

eoffsetdata = etrimdata-min(etrimdata)
enormaldata = eoffsetdata/max(eoffsetdata)#normalize

axaxis = np.arange(len(atrimdata)) * asamp_period # Make our axis go from 0 to the length of our recording
ax_vals= np.arange(len(atrimdata))*(1/20)

aoffsetdata = atrimdata-min(atrimdata)
anormaldata = aoffsetdata/max(aoffsetdata)#normalized

eguess_parameters_ = [1, 1] ##perform least squares and fit for electric guitar
eres_lsq = least_squares(get_residuals, eguess_parameters_, args = (enormaldata,ex_vals))
eparameters= eres_lsq['x']
ey_vals = modeled(exaxis, eparameters)

plt.plot(ex_vals, ey_vals, color="red", label="Fitted Electric Data")
plt.plot(exaxis, enormaldata, color='blue', label='Normal Electric Data')

aguess_parameters_ = [1, 1] ##perform least squares and fit for acoustic guitar
ares_lsq = least_squares(get_residuals, aguess_parameters_, args = (anormaldata,ax_vals))
aparameters= ares_lsq['x']
ay_vals = modeled(axaxis, aparameters)

plt.plot(ax_vals, ay_vals, color="green", label="Fitted Acoustic Data")
plt.plot(axaxis, anormaldata, color='brown', label ='Normal Acoustic Data')
plt.title('G Dampening over Time')
plt.xlabel('Time (s)')#graph labeling
plt.ylabel('Intensity')
plt.legend()
print(eparameters)
print(aparameters)

import numpy as np
import matplotlib.pyplot as plt
rate, data = wavfile.read('/content/electric g.wav')#import sound wavr
number_of_values = len(data)#number of data pts
time_per_sample = 1. / rate
time_arr = np.arange(number_of_values) * time_per_sample#create range for time
plt.plot(time_arr, data)#plot wave

from scipy.io import wavfile
rate, data = wavfile.read('/content/electric d.wav')
import matplotlib.pyplot as plt
samp_period = 1. / rate
num_data_points = len(data)
print('Sampling Rate: ' + str(rate))
xaxis = np.arange(len(data)) * samp_period # Make our axis go from 0 to the length of our recording
plt.plot(xaxis, data)
plt.xlabel('Time (s)')
plt.ylabel('Intensity')

from scipy.fftpack import fft
import numpy as np
fft_out = fft(data)

# Create an array that goes from 0 to the 44100 Hz
frequencies = np.linspace(0,1,num_data_points) * rate
plt.plot(frequencies,np.abs(fft_out))
plt.xlim([140, 160])